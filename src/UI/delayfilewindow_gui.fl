# data file for the Fltk User Interface Designer (fluid)
version 1.0305
header_name {.h}
code_name {.cxx}
decl {\#include <FL/Fl_File_Chooser.H>} {public global
}

decl {\#include <unistd.h>} {public global
}

decl {\#include "RKR_Button.h"} {public global
}

decl {\#include "RKR_Group.h"} {public global
}

decl {\#include "RKR_Scroll.h"} {public global
}

decl {\#include "RKR_Value_Input.h"} {public global
}

decl {\#include "../Echotron.h"} {public global
}

decl {\#include "rakarrack.h"} {public global
}

decl {struct DelayLine
{
    float pan;
    float time;
    float level;
    float LP;
    float BP;
    float HP;
    float freq;
    float Q;
    int stages;
    
    DelayLine() :
    pan(),
    time(1.0),
    level(0.7),
    LP(1.0),
    BP(-1.0),
    HP(1.0),
    freq(800.0),
    Q(2),
    stages(1) {}
};} {public global
}

widget_class DelayFileWindowGui {
  label {Echotron Delay File} open
  xywh {2 415 605 265} type Double resizable
  code0 {this->m_rkr = NULL;
this->m_rgui = NULL;}
  class Fl_Double_Window visible
} {
  decl {int m_file_size;} {private local
  }
  decl {RKRGUI* m_rgui;} {private local
  }
  decl {RKR* m_rkr;} {private local
  }
  decl {DlyFile m_delay_file;} {private local
  }
  decl {std::vector<DelayLine> m_vct_delay_line;} {private local
  }
  Fl_Group Delay_Group {open
    xywh {0 0 605 265}
    class RKR_Group
  } {
    Fl_Value_Input dly_filter {
      label Filter
      xywh {25 25 40 25} align 1 maximum 100 step 0.1 value 1
      class RKR_Value_Input
    }
    Fl_Value_Input dly_delay {
      label Delay
      xywh {90 25 40 25} align 1 maximum 100 step 0.1 value 1
      class RKR_Value_Input
    }
    Fl_Value_Input dly_Q_mode {
      label {Q Mode}
      xywh {164 25 20 25} align 1 step 1
      class RKR_Value_Input
    }
    Fl_Button {} {
      label Load
      callback {char *filename;
filename=fl_file_chooser("Load dly File:","(*.dly)",NULL,0);
if (filename==NULL) return;
filename=fl_filename_setext(filename,".dly");
//strcpy(rkr->efx_Echotron->Filename,filename);

DlyFile delay_file = rkr->efx_Echotron->loadfile(filename);

load_delay_file(delay_file);}
      xywh {210 25 70 20}
      class RKR_Button
    }
    Fl_Button {} {
      label Save
      callback {char *filename;
\#define EXT ".dly"
filename=fl_file_chooser("Save delay file:","(*" EXT")", NULL/*rkr->Preset_Name*/,0);
if (filename==NULL) return;
filename=fl_filename_setext(filename,EXT);
\#undef EXT
save_delay_file(filename);}
      xywh {290 25 70 20}
      class RKR_Button
    }
    Fl_Button {} {
      label New
      callback {m_file_size = 0;
dly_filter->value(1);
dly_delay->value(1);
dly_Q_mode->value(0);
dly_scroll->clear();
add_button->do_callback();}
      xywh {375 25 70 20}
      class RKR_Button
    }
    Fl_Button add_button {
      label {+}
      callback {m_file_size++;

dlyFileGroup *ADDG = new dlyFileGroup(30, (m_file_size * 30) + (60 - dly_scroll->yposition()), 540, 30);
ADDG->initialize(this);
//printf("Before X = %d: Y = %d\\n", dly_scroll->xposition(), dly_scroll->yposition());

std::stringstream strs;
strs << m_file_size;
std::string temp_str = strs.str();
char* char_type = (char*) temp_str.c_str();
ADDG->dly_occur->copy_label(char_type);

dly_scroll->add(ADDG);
dly_scroll->redraw();

//dly_scroll->scroll_to(dly_scroll->xposition(), m_file_size * 30);

//printf("After X = %d: Y = %d\\n", dly_scroll->xposition(), dly_scroll->yposition());}
      tooltip {Add Delay Line} xywh {464 22 25 25} labelsize 21
      class RKR_Button
    }
    Fl_Round_Button {} {
      label Apply
      tooltip {Apply Changes to Echotron} xywh {513 22 72 25} type Normal box ROUND_UP_BOX down_box ROUND_DOWN_BOX
    }
    Fl_Group dly_group {
      label {  Pan           Time        Level          LP          BP          HP      Freq          Q       Stages  } open
      xywh {34 81 543 20}
      class RKR_Group
    } {}
    Fl_Scroll dly_scroll {open
      xywh {25 88 560 165}
    } {}
  }
  Function {make_delay_window()} {} {
    code {// The First Item is always added

add_button->do_callback();} {}
  }
  Function {initialize(RKR *_rkr,RKRGUI *_rgui)} {} {
    code {m_file_size = 0;
m_rkr = _rkr;
m_rgui= _rgui;} {}
  }
  Function {load_delay_file(DlyFile delay_file)} {private
  } {
    code {dly_scroll->clear();
  m_file_size = 0;
    dly_filter->value(delay_file.subdiv_fmod);
    dly_delay->value(delay_file.subdiv_dmod);
    dly_Q_mode->value(delay_file.f_qmode);
    
    for(int i = 0; i < delay_file.fLength; ++i)
    {
        m_file_size++;

        dlyFileGroup *ADDG = new dlyFileGroup(30, (m_file_size * 30) + (60 - dly_scroll->yposition()), 540, 30);
        ADDG->initialize(this);

        ADDG->dly_pan->value(delay_file.fPan[i]);
        ADDG->dly_time->value(delay_file.fTime[i]);
        ADDG->dly_level->value(delay_file.fLevel[i]);
        ADDG->dly_LP->value(delay_file.fLP[i]);
        ADDG->dly_BP->value(delay_file.fBP[i]);
        ADDG->dly_HP->value(delay_file.fHP[i]);
        ADDG->dly_freq->value(delay_file.fFreq[i]);
        ADDG->dly_Q->value(delay_file.fQ[i]);
        ADDG->dly_stages->value(delay_file.iStages[i] + 1);	// offset by 1

        std::stringstream strs;
        strs << m_file_size;
        std::string temp_str = strs.str();
        char* char_type = (char*) temp_str.c_str();
        ADDG->dly_occur->copy_label(char_type);

        dly_scroll->add(ADDG);
    }

this->redraw();} {}
  }
  Function {save_delay_file(char *filename)} {} {
    code {DlyFile delay_file = get_current_settings();

    FILE *fn;
    char buf[256];
    fn = fopen(filename, "w");

    if (errno == EACCES)
    {
        rkr->Error_Handle(3);
        fclose(fn);
        return;
    }
    
        //General
    memset(buf, 0, sizeof (buf));
    sprintf(buf, "%f\\t%f\\t%d\\n",delay_file.subdiv_fmod, delay_file.subdiv_dmod, delay_file.f_qmode);
    fputs(buf, fn);
    
    for(int i = 0; i < m_file_size; ++i)
    {
    
        memset(buf, 0, sizeof (buf));
        sprintf
        (
        buf, "%f\\t%f\\t%f\\t%f\\t%f\\t%f\\t%f\\t%f\\t%d\\n",
        delay_file.fPan[i],
        delay_file.fTime[i],
        delay_file.fLevel[i],
        delay_file.fLP[i],
        delay_file.fBP[i],
        delay_file.fHP[i],
        delay_file.fFreq[i],
        delay_file.fQ[i],
        (delay_file.iStages[i] + 1)
        );
        fputs(buf, fn);
    }
    
    fclose(fn);} {}
  }
  Function {get_current_settings()} {private return_type DlyFile
  } {
    code {DlyFile delay_file;
  
  delay_file.subdiv_fmod = dly_filter->value();
  delay_file.subdiv_dmod = dly_delay->value();
  delay_file.f_qmode = dly_Q_mode->value();
  
  for(int i = 0; i < m_file_size; ++i)
  {
    Fl_Widget *c = dly_scroll->child(i);
    dlyFileGroup *c_choice = (dlyFileGroup *) c;
      
    delay_file.fPan[i] = c_choice->dly_pan->value();
    delay_file.fTime[i] = c_choice->dly_time->value();
    delay_file.fLevel[i] = c_choice->dly_level->value();
    delay_file.fLP[i] = c_choice->dly_LP->value();
    delay_file.fBP[i] = c_choice->dly_BP->value();
    delay_file.fHP[i] = c_choice->dly_HP->value();
    delay_file.fFreq[i] = c_choice->dly_freq->value();
    delay_file.fQ[i] = c_choice->dly_Q->value();
    delay_file.iStages[i] = (c_choice->dly_stages->value() - 1);
  }
  
  return delay_file;} {}
  }
  Function {update_scroll(int group)} {return_type void
  } {
    code {m_vct_delay_line.clear();

  for(int i = 0; i < m_file_size; ++i)
  {
      Fl_Widget *c = dly_scroll->child(i);
      dlyFileGroup *c_choice = (dlyFileGroup *) c;
      
      if(group == i)
          continue;
      
      DelayLine d_choice;
      d_choice.pan = c_choice->dly_pan->value();
      d_choice.time = c_choice->dly_time->value();
      d_choice.level = c_choice->dly_level->value();
      d_choice.LP = c_choice->dly_LP->value();
      d_choice.BP = c_choice->dly_BP->value();
      d_choice.HP = c_choice->dly_HP->value();
      d_choice.freq = c_choice->dly_freq->value();
      d_choice.Q = c_choice->dly_Q->value();
      d_choice.stages = (c_choice->dly_stages->value() - 1);
      
      m_vct_delay_line.push_back(d_choice);
  }
  
  dly_scroll->clear();
  m_file_size = 0;
  
      for(unsigned i = 0; i < m_vct_delay_line.size(); ++i)
      {
          m_file_size++;
  
          dlyFileGroup *ADDG = new dlyFileGroup(30, (m_file_size * 30) + (60 - dly_scroll->yposition()), 540, 30);
          ADDG->initialize(this);
  
          ADDG->dly_pan->value(m_vct_delay_line[i].pan);
          ADDG->dly_time->value(m_vct_delay_line[i].time);
          ADDG->dly_level->value(m_vct_delay_line[i].level);
          ADDG->dly_LP->value(m_vct_delay_line[i].LP);
          ADDG->dly_BP->value(m_vct_delay_line[i].BP);
          ADDG->dly_HP->value(m_vct_delay_line[i].HP);
          ADDG->dly_freq->value(m_vct_delay_line[i].freq);
          ADDG->dly_Q->value(m_vct_delay_line[i].Q);
          ADDG->dly_stages->value(m_vct_delay_line[i].stages + 1);	// offset by 1
  
          std::stringstream strs;
          strs << m_file_size;
          std::string temp_str = strs.str();
          char* char_type = (char*) temp_str.c_str();
          ADDG->dly_occur->copy_label(char_type);
  
          dly_scroll->add(ADDG);
      }
  
  this->redraw();} {selected
    }
  }
}

widget_class dlyFileGroup {open
  xywh {886 839 540 30} type Double visible position_relative
} {
  decl {DelayFileWindowGui *m_parent;} {private local
  }
  Fl_Value_Input dly_pan {
    xywh {6 6 40 20} labeltype NO_LABEL align 1 minimum -1 step 0.01
    class RKR_Value_Input
  }
  Fl_Value_Input dly_time {
    xywh {49 6 40 20} labeltype NO_LABEL align 1 minimum -6 maximum 6 step 0.001 value 1
    class RKR_Value_Input
  }
  Fl_Value_Input dly_level {
    xywh {101 6 45 20} labeltype NO_LABEL align 1 minimum -10 maximum 10 step 0.001 value 0.7
    class RKR_Value_Input
  }
  Fl_Value_Input dly_LP {
    xywh {160 6 42 20} labeltype NO_LABEL align 1 minimum -2 maximum 2 step 0.001 value 1
    class RKR_Value_Input
  }
  Fl_Value_Input dly_BP {
    xywh {210 6 42 20} labeltype NO_LABEL align 1 minimum -2 maximum 2 step 0.001 value -1
    class RKR_Value_Input
  }
  Fl_Value_Input dly_HP {
    xywh {260 6 42 20} labeltype NO_LABEL align 1 minimum -2 maximum 2 step 0.001 value 1
    class RKR_Value_Input
  }
  Fl_Value_Input dly_freq {
    xywh {310 6 46 20} labeltype NO_LABEL align 1 minimum 20 maximum 26000 step 0.001 value 800
    class RKR_Value_Input
  }
  Fl_Value_Input dly_Q {
    xywh {366 6 44 20} labeltype NO_LABEL align 1 maximum 300 step 0.01 value 2
    class RKR_Value_Input
  }
  Fl_Value_Input dly_stages {
    xywh {425 6 20 20} labeltype NO_LABEL align 1 minimum 1 maximum 5 step 1 value 1
    class RKR_Value_Input
  }
  Fl_Button dly_delete {
    label D
    user_data 0
    callback {Fl_Widget * P = o->parent();
  
dlyFileGroup *Choice = (dlyFileGroup *) P;

std::stringstream strValue;
strValue << Choice->dly_occur->label();

int intValue;
strValue >> intValue;


m_parent->update_scroll(intValue - 1); // offset by 1}
    tooltip {Delete This Line} xywh {453 6 20 20} align 16
    class RKR_Button
  }
  Fl_Box dly_occur {
    label 1
    xywh {481 6 35 20} align 20
    class RKR_Box
  }
  Fl_Button dly_insert {
    label I
    user_data 0
    callback {printf("Insert Pressed\\n");}
    tooltip {Insert New Delay Line Before Current} xywh {516 6 20 20} align 16
    class RKR_Button
  }
  Function {initialize(DelayFileWindowGui *parent)} {return_type void
  } {
    code {m_parent = parent;} {}
  }
}
